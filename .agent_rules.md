# Rules for AI

## 1. Code Quality

- **Follow Rubocop**: Always consider our Rubocop rules when writing code. If uncertain about a style or convention, check `.rubocop.yml` or existing code patterns.

## 2. Techniques & Standards

### Ruby Style

**Use Hash Value Omission**: For Ruby 3.1+ code, use hash value omission syntax when the key and value are the same.

- **BAD**: `{ instance: instance, duration: duration }`
- **GOOD**: `{ instance:, duration: }`
- **BAD**: `create(:account, instance: instance, status: status)`
- **GOOD**: `create(:account, instance:, status:)`

This applies to:

- Method arguments
- Hash literals
- Factory definitions
- Any hash where keys match variable names

**Avoid Ugly Multi-line Formatting**: When array or hash elements span multiple lines, put each element on its own line. Never create partial multi-line elements that result in awkward `,],` or `,),` patterns on the same line.

- **BAD** - partial multi-line creates ugly `,],`:

  ```ruby
  rows: [
    ['Label', format_number(value),
     format_change(value, previous),],
  ]
  ```

- **GOOD** - each element on its own line:

  ```ruby
  rows: [
    [
      'Label',
      format_number(value),
      format_change(value, previous),
    ],
  ]
  ```

- **ALSO GOOD** - single line if short enough:
  ```ruby
  rows: [
    ['Label', format_number(value), format_change(value, previous)],
  ]
  ```

Note: Trailing commas are fine (and enforced by Rubocop). The issue is the _formatting_ that creates visual clutter.

### ActiveRecord Queries

**Use Ruby Ranges**: Prefer Ruby range syntax over string comparisons for date/time and numeric ranges.

- **BAD**: `.where('created_at > ?', 1.day.ago)`
- **GOOD**: `.where(created_at: 1.day.ago..)` (Use endless range for `>=`)
- **GOOD**: `.where(created_at: ..1.day.ago)` (Use beginless range for `<=`)
- **GOOD**: `.where(created_at: ...1.day.ago)` (Use range with 3 dots for `<`)

### Exception Handling

Always specify the exception class in rescue clauses:

- **BAD**: `rescue => e`
- **GOOD**: `rescue StandardError => e`
- **BETTER**: `rescue SpecificError => e`

Let errors propagate naturally unless you have a specific reason to catch them.

### Database migrations

Always use `rails generate migration` to create new migrations. Avoid creating migration files manually to ensure proper timestamps and naming conventions.

## 3. Architecture

**No Side Effects in Models**: Avoid putting side-effects (like sending notifications or enqueuing jobs) in models. These belong in the Service Layer / Interactors.

## 4. Testing

### Validation Testing

**DO NOT** write specs that test basic ActiveRecord validations like:

- `validates :field, presence: true`
- `validates :field, uniqueness: true`
- `validates :field, numericality: true`
- Other standard Rails validations

#### Why?

- These validations are tested by Rails itself
- They add maintenance overhead without adding value
- They make specs brittle to simple model changes

#### What to test instead:

- Complex custom validations with business logic
- Validation behavior in integration/request specs
- The actual user-facing behavior that relies on validations

#### Examples:

**BAD** - Testing simple validations:

```ruby
describe FacebookDataDeletionRequest do
  it { is_expected.to validate_presence_of(:facebook_user_id) }
  it { is_expected.to validate_uniqueness_of(:confirmation_code) }
end
```

**GOOD** - Testing through behavior:

```ruby
describe 'POST /webhooks/facebook/data_deletion' do
  subject(:request) do
    post '/webhooks/facebook/data_deletion', params: { signed_request:}
  end

  let(:signed_request) { { user_id: '12345', algorithm: 'HMAC-SHA256' } }

  it 'creates a deletion request' do
    expect { request }.to change(FacebookDataDeletionRequest, :count).by(1)

    expect(response).to have_http_status(:ok)
  end
end
```

**GOOD** - Testing complex custom validations:

```ruby
describe 'custom validation' do
  subject(:request) { described_class.new(start_date:, end_date:) }

  context 'when both start_date and end_date are present' do
    let(:start_date) { Date.today }
    let(:end_date) { Date.yesterday }

    it 'requires end_date to be after start_date' do
      expect(request).not_to be_valid
      expect(request.errors[:end_date]).to include('must be after start date')
    end
  end
end
```

### Mocks and Spies

Prefer using `instance_spy` and the `expect(...).to receive` style for verification over `have_received`. This mocking style is generally more readable and separates setup from verification effectively.

Use `instance_spy` primarily when you stub the initializer to return the spy. This allows you to avoid defining the interface of a double explicitly, as spies allow any message.

**BAD**:

```ruby
let(:client) { instance_double(ClientClass, call: nil) }

before do
  allow(ClientClass).to receive(:new).and_return(client)
end

it 'calls the client' do
  subject.perform
  expect(client).to have_received(:call)
end
```

**GOOD**:

```ruby
let(:client) { instance_spy(ClientClass) }

before do
  allow(ClientClass).to receive(:new).and_return(client)
end

it 'calls the client' do
  expect(client).to receive(:call)
  subject.perform
end
```

#### For Class Methods

For class methods, set expectations directly before the action - do not use `allow` + `have_received`.

**BAD**:

```ruby
before do
  allow(AnalyticsJob).to receive(:perform_async)
end

it 'enqueues analytics job' do
  action.call

  expect(AnalyticsJob).to have_received(:perform_async).with(
    :event_name, user_id, company_id, anything,
  )
end
```

**GOOD**:

```ruby
it 'enqueues analytics job' do
  expect(AnalyticsJob).to receive(:perform_async).with(
    :event_name, user_id, company_id, anything,
  )

  action.call
end
```

### Use Contexts for Conditional Scenarios

Always use `context` blocks to organize specs by conditions or states. This makes specs more readable and clearly separates different scenarios.

**Use `context` for:**

- Different states: `context 'when user is authenticated'`
- Different inputs: `context 'with valid params'`
- Different configurations: `context 'with feature flag enabled'`
- Error conditions: `context 'when API fails'`
- Variations: `context 'with force: true'`

**BAD**:

```ruby
describe '#call' do
  it 'returns error for claimed account' do
    # ...
  end

  it 'deactivates unclaimed account' do
    signals_account.update!(company: nil)
    # ...
  end

  it 'sends analytics when company is present' do
    # ...
  end
end
```

**GOOD**:

```ruby
describe '#call' do
  context 'with claimed account' do
    it 'returns an error without deactivating' do
      # ...
    end
  end

  context 'with one-click unclaimed account' do
    let(:signals_account) { create(:signals_account, company: nil) }

    it 'updates status to deactivated' do
      # ...
    end

    it 'does not enqueue analytics job without company' do
      # ...
    end
  end

  context 'when API fails' do
    before do
      allow(client).to receive(:delete_account).and_raise(Signals::ApiError)
    end

    it 'captures exception and returns error' do
      # ...
    end
  end
end
```

**Benefits:**

- Clear separation of different scenarios
- Easier to locate specific test cases
- Better test organization and readability
- `let` blocks can be scoped to specific contexts

### Side-Effect Records in Before Blocks

When creating records that exist only for their side effects (not directly referenced in tests), use `before` blocks instead of `let!`. This keeps `let` blocks clean and focused on records that are actually referenced.

**BAD** - Creating side-effect records in `let!`:

```ruby
let!(:account_with_error) do
  account = create(:signals_account, status: :active, company:)
  create(:signals_pipeline, signals_account: account, signals_pixel_error: 'Error')
  account
end
```

**GOOD** - Separate the side-effect into a `before` block:

```ruby
let!(:account_with_error) do
  create(:signals_account, status: :active, company:)
end

before do
  create(:signals_pipeline, signals_account: account_with_error, signals_pixel_error: 'Error')
end
```

**Why?**

- `let` blocks should return the record they're named after
- Side effects hidden inside `let` blocks are harder to understand
- `before` blocks clearly signal "setup that happens before tests"
- Makes test data setup more explicit and readable

## 5. Workflow

- **Run DB migrations**: Make sure to always run any pending database migrations with `rails db:migrate RAILS_ENV=test` command before running tests.
- **Run Verification**: Once a chunk of work is completed, always run both Rubocop checks and relevant tests to ensure no regressions or style violations.
